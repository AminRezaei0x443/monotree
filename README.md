[![Build Status](https://travis-ci.com/thyeem/monotree.svg?token=QYwxZ27j8uz6zsrzY6bk&branch=monotree)](https://travis-ci.com/thyeem/monotree)
# Monotree
Rust implementation of an optimized Sparse Merkle Tree.   
This is a kind of binary-radix tree based on bitwise branching.   
Currently, no lump of bit (nor a 4-bit lump neither a byte lump).    
The branching unit is just a single bit here.  

## Features
- Very simple, concise and ___easy to read___, but ___fast___ and robust.  
- __Fully featured__ Sparse Merkle Tree (SMT) as a storage 
- <ins>This includes: ___non-inclusion proof___ , ___inclusion proof___, and _its verification_.</ins>
- Again, NOT verbose at all.  

## Performance
<ins>All benchmarks were performed in a cumulative way</ins>, where the root resulting from an operation just before was reused for subsequent operations.
They were carried out with _randomly-generated bytes entries and from the root of an empty tree_. (The last root was used when deleting)      

Tested on: _MacBook Pro (2.7 GHz Intel Core i5 and 16 GB 1867 MHz DDR3)_ with rustc stable 1.42.0    

| operation | DB used | #entries | time measured | standard error | on average / op. |
| :-------: | :-----: | -------: | :-----------: | :------------: | :--------------: |
|  Insert   | HashMap |       10 |   25.36 us    |    0.18 us     |     2.54 us      |
|  Insert   | HashMap |      100 |   456.22 us   |    3.79 us     |     4.56 us      |
|  Insert   | HashMap |     1000 |    7.01 ms    |    0.02 ms     |     7.01 us      |
|  Insert   | HashMap |    10000 |   108.29 ms   |    0.18 ms     |     10.83 us     |
|  Insert   | RocksDB |       10 |   67.33 us    |    1.63 us     |     6.73 us      |
|  Insert   | RocksDB |      100 |   994.77 us   |    19.17 us    |     9.95 us      |
|  Insert   | RocksDB |     1000 |   19.42 ms    |    0.30 ms     |     19.42 us     |
|  Insert   | RocksDB |    10000 |   295.76 ms   |    5.67 ms     |     29.58 us     |
|    Get    | HashMap |       10 |   15.49 us    |    0.08 us     |     1.55 us      |
|    Get    | HashMap |      100 |   235.47 us   |    2.29 us     |     2.35 us      |
|    Get    | HashMap |     1000 |    3.21 ms    |    0.02 ms     |     3.21 us      |
|    Get    | HashMap |    10000 |   41.83 ms    |    0.16 ms     |     4.18 us      |
|    Get    | RocksDB |       10 |   16.86 us    |    0.11 us     |     1.69 us      |
|    Get    | RocksDB |      100 |   262.71 us   |    2.04 us     |     2.63 us      |
|    Get    | RocksDB |     1000 |    3.53 ms    |    0.03 ms     |     3.53 us      |
|    Get    | RocksDB |    10000 |   45.95 ms    |    0.27 ms     |     4.60 us      |
|  Delete   | HashMap |       10 |   40.62 us    |    0.28 us     |     4.06 us      |
|  Delete   | HashMap |      100 |   781.36 us   |    6.82 us     |     7.81 us      |
|  Delete   | HashMap |     1000 |   13.10 ms    |    0.17 ms     |     13.10 us     |
|  Delete   | HashMap |    10000 |   182.33 ms   |     2.4 ms     |     18.23 us     |
|  Delete   | RocksDB |       10 |   107.93 us   |    1.75 us     |     10.80 us     |
|  Delete   | RocksDB |      100 |    1.76 ms    |    15.8 us     |     17.60 us     |
|  Delete   | RocksDB |     1000 |   37.03 ms    |    0.17 ms     |     37.03 us     |
|  Delete   | RocksDB |    10000 |   644.83 ms   |    2.17 ms     |     64.48 us     |


## Dependancies
This library mostly relies on the _Rust standard library only_ except for hash function (`Blake2`) and database API (`Rocksdb`).

## Usage
How to generate and manipulate a new `monotree` instance

### Outline
```rust
    // init database, where DBTYPE := MemoryDB | RocksDB
    let mut tree = tree::Monotree::<DBTYPE>::new(DB_PATH_OR_NAME);
    let mut root = tree.new_tree();

    // ... do something with `tree` and `root`
```

### Example
 ```rust
    use monotree::consts::HASH_LEN;
    use monotree::database::{MemoryDB, RocksDB};
    use monotree::tree::Monotree;
    use monotree::utils::*;
    use monotree::*;

    fn main() {
        // prepare some random hashes for keys and leaves
        let keys = random_hashes(100);
        let leaves = random_hashes(100);

        // init tree using either In-Memory HashMap
        let mut tree = tree::Monotree::<MemoryDB>::new("");
        // or RocksDB. Use only one of them at a time
        let mut tree = tree::Monotree::<RocksDB>::new(DB_PATH);
        let mut root = tree.new_tree();
        
        // insert keys example with some assertions
        keys.iter().zip(leaves.iter()).enumerate().for_each(|(i, (key, value))| {
            // insert a key
            root = tree.insert(root.as_ref(), key, value).unwrap();
        
            //--- functional test: insert/get
            keys.iter().zip(leaves.iter()).take(i + 1).for_each(|(k, v)| {
                // check if the key-value pair was correctly inserted so far
                assert_eq!(tree.get(root.as_ref(), k).unwrap(), Some(*v));
            });
        });
        assert_ne!(root, None);
        
        // delete keys example with some assertions
        keys.iter().zip(leaves.iter()).enumerate().for_each(|(i, (key, _))| {
        
            //--- functional test: remove
            // assert that all values are fine after deletion
            assert_ne!(root, None);
            keys.iter().zip(leaves.iter()).skip(i).for_each(|(k, v)| {
                assert_eq!(tree.get(root.as_ref(), k).unwrap(), Some(*v));
            });
        
            // delete a key
            root = tree.remove(root.as_ref(), key).unwrap();
        
            // check if the key was correctly deleted
            assert_eq!(tree.get(root.as_ref(), key).unwrap(), None);
        });
        
        // back to inital state of tree
        assert_eq!(root, None);
    }
}
 ```
## Merkle proof generation: prove/verify inclusion of data
### Outline
```rust
    // generate a proof simply,
    let proof = tree.get_merkle_proof(ROOT_REF, KEY_REF)?.unwrap();

    // verify proof: returns true or false as the result
    tree::verify_proof(ROOT_REF, VALUE, PROOF_REF)
```
### Example
```rust
    use monotree::tree;
    use monotree::database::MemoryDB;
    use monotree::utils::*;

    // prepare some random hashes for keys and leaves
    let keys = random_hashes(100);
    let leaves = random_hashes(100);
    // init a Monotree
    let mut tree = tree::Monotree::<MemoryDB>::new("");
    let mut root = tree.new_tree();

   // INTEGRITY: cumalative funtional test
   keys.iter().zip(leaves.iter()).enumerate().for_each(|(i, (key, value))| {
       // insert each key and update root
       root = tree.insert(root.as_ref(), key, value).unwrap();

       // where generate/verify Merkle proofs with all keys inserted so far
       keys.iter().zip(leaves.iter()).take(i + 1).for_each(|(k, v)| {
           let proof = tree.get_merkle_proof(root.as_ref(), k).unwrap().unwrap();
           assert_eq!(tree::verify_proof(root.as_ref(), v, &proof), true);
       });
   });
```

## Further improvements
`monotree` is a special case among the generalized binary radix trees, I'd like to call it `PoT (Power Of Two) radix tree`.   
<ins>_If the `monotree` were generalized with `pow(2, n)` lumps or nibbles as a unit node_</ins>, there would have been room for further performance improvement.   
This generalization would be future-work.


## Integration tests and benchmark
performs integration tests including some unit tests.
```bash
    ## Some tests are time consuming.
    ## --release is optional, but without it, it will take a longer time to complete the tests
    $ cargo test --release
```

performs a micro-benchmark based on _Criterion [https://crates.io/crates/criterion]_
```bash
    $ cargo bench
```

and a macroscopic-time benchmark (but rather wider error bars) was also prepared in `perf.rs`.

```rust
    use monotree::perf;
    fn main() {
        perf::perf();
    }
```
```bash
    $ cargo run --release
```