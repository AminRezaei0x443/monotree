# Monotree
Rust implementation of an optimized Sparse Merkle Tree.   
This is a kind of binary-radix tree based on bitwise branching.   
Currently, no lump of bit (nor a 4-bit lump neither a byte lump).    
The branching unit is just a single bit here.  

## Features
- Very simple, concise and ___easy to read___, but ___fast___ and robust.  
- __Fully featured__ Sparse Merkle Tree (SMT) as a storage 
- <ins>This includes: ___non-inclusion proof___ , ___inclusion proof___, and _its verification_.</ins>
- Again, NOT verbose at all.  

## Performance
<ins>All benchmarks were performed in a cumulative way</ins>, where the root resulting from an operation just before was reused for subsequent operations.
They were carried out with _randomly-generated bytes entries and from the root of an empty tree_. (The last root was used when deleting)      

Tested on: _MacBook Pro (2.7 GHz Intel Core i5 and 16 GB 1867 MHz DDR3)_ with rustc stable 1.42.0    

| Operation | DB used | #Entries | Time measured |
| :-------: | :-----: | -------: | :-----------: |
|  Insert   | HashMap |       10 |   26.98 us    |
|  Insert   | HashMap |      100 |   456.22 us   |
|  Insert   | HashMap |     1000 |    7.01 ms    |
|  Insert   | HashMap |    10000 |   110.18 ms   |
|  Insert   | RocksDB |       10 |   70.09 us    |
|  Insert   | RocksDB |      100 |   994.77 us   |
|  Insert   | RocksDB |     1000 |   19.42 ms    |
|  Insert   | RocksDB |    10000 |   306.32 ms   |
|    Get    | HashMap |       10 |       ?       |
|    Get    | HashMap |      100 |       ?       |
|    Get    | HashMap |     1000 |       ?       |
|    Get    | HashMap |    10000 |       ?       |
|    Get    | RocksDB |       10 |       ?       |
|    Get    | RocksDB |      100 |       ?       |
|    Get    | RocksDB |     1000 |       ?       |
|    Get    | RocksDB |    10000 |       ?       |
|  Delete   | HashMap |       10 |       ?       |
|  Delete   | HashMap |      100 |       ?       |
|  Delete   | HashMap |     1000 |       ?       |
|  Delete   | HashMap |    10000 |       ?       |
|  Delete   | RocksDB |       10 |       ?       |
|  Delete   | RocksDB |      100 |       ?       |
|  Delete   | RocksDB |     1000 |       ?       |
|  Delete   | RocksDB |    10000 |       ?       |


## Dependancies
This library mostly relies on the _Rust standard library only_ except for hash function (`Blake2`) and database API (`Rocksdb`).

## Usage
How to generate and manipulate a new `monotree` instance

### Outline
```rust
    // init database, where DBTYPE := MemoryDB | RocksDB
    let mut tree = tree::Monotree::<DBTYPE>::new(DB_PATH_OR_NAME);
    let mut root = tree.new_tree();

    // ... do something with `tree` and `root`
```

### Example
 ```rust
    use monotree::consts::HASH_LEN;
    use monotree::database::{MemoryDB, RocksDB};
    use monotree::tree::Monotree;
    use monotree::utils::*;
    use monotree::*;

    fn main() {
        /// gen random 10000 key-value pair
        let pairs: Vec<(Hash, Hash)> = (0..10000)
            .map(|_| (random_bytes(HASH_LEN), random_bytes(HASH_LEN)))
            .map(|x| (slice_to_hash(&x.0).unwrap(), slice_to_hash(&x.1).unwrap()))
            .collect();

        // init tree using either In-Memory HashMap
        let mut tree = tree::Monotree::<MemoryDB>::new(DB_NAME);
        // or RocksDB. Use only one of them at a time
        let mut tree = tree::Monotree::<RocksDB>::new(DB_PATH);
        let mut root = tree.new_tree();
        
        // insert keys example with some assertions
        pairs.iter().enumerate().for_each(|(i, (key, value))| {
            // insert a key
            root = tree.insert(root.as_ref(), key, value).unwrap();

            //--- functional test: insert/get
            pairs.iter().take(i + 1).for_each(|(k, v)| {
                // check if the key-value pair was correctly inserted so far
                assert_eq!(tree.get(root.as_ref(), k).unwrap(), Some(*v));
            });
        });
        assert_ne!(root, None);

        // delete keys example with some assertions
        pairs.iter().enumerate().for_each(|(i, (key, _))| {

            //--- functional test: remove
            // assert that all values are fine after deletion
            assert_ne!(root, None);
            pairs.iter().skip(i).for_each(|(k, v)| {
                assert_eq!(tree.get(root.as_ref(), k).unwrap(), Some(*v));
            });

            // delete a key
            root = tree.remove(root.as_ref(), key).unwrap();

            // check if the key was correctly deleted
            assert_eq!(tree.get(root.as_ref(), key).unwrap(), None);
        });

        // back to inital state of tree
        assert_eq!(root, None);
    }
}
 ```
## Merkle proof generation: prove/verify inclusion of data
### Outline
```rust
    // generate a proof simply,
    let proof = tree.get_merkle_proof(ROOT_REF, KEY_REF)?.unwrap();

    // verify proof: returns true or false as the result
    tree::verify_proof(ROOT_REF, VALUE, PROOF_REF)
```
### Example
```rust
    // suppose (key: Hash, value: Hash) alreay prepared.
    // let mut root = ...
    root = tree.insert(&root, &key, &value);
    ...

    // get a leaf related to the key interested
    let leaf = tree.get(root.as_ref(), &key).unwrap();

    // generate a proof related to the key interested
    let proof = tree.get_merkle_proof(root.as_ref(), &key)?.unwrap();

    // check if the proof is correct or not
    assert_eq!(tree::verify_proof(root.as_ref(), &leaf, &proof), true);

    // integrity: cumalative funtional test
    pairs.iter().enumerate().for_each(|(i, (key, value))| {
        // insert a key
        root = tree.insert(root.as_ref(), key, value).unwrap();

        // genenrate and verify Merkle proof with all keys so far
        pairs.iter().take(i + 1).for_each(|(k, v)| {
            let proof = tree.get_merkle_proof(root.as_ref(), k).unwrap().unwrap();
            assert_eq!(tree::verify_proof(root.as_ref(), v, &proof), true);
        });
    });
```

## Further improvements
`monotree` is a special case among the generalized binary radix trees, I'd like to call it `PoT (Power Of Two) radix tree`.   
<ins>_If the `monotree` were generalized with `pow(2, n)` lumps or nibbles as a unit node_</ins>, there would have been room for further performance improvement.   
This generalization would be future-work.


## Integration tests and benchmark
performs integration tests including some unit tests.
```bash
    ## Some tests are time consuming.
    ## --release is optional, but without it, it will take a longer time to complete the tests
    $ cargo test --release
```

performs a micro-benchmark based on _Criterion [https://crates.io/crates/criterion]_
```bash
    $ cargo bench
```

and a macroscopic-time benchmark (but rather wider error bars) was also prepared in `perf.rs`.
```bash
    $ cargo run --release
```