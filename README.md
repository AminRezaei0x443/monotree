# MonoTree
Rust implementation of an optimized Sparse Merkle Tree.   
This is a kind of binary-radix tree based on bitwise branching.   
Currently, no nibbles or lumps of bit (nor a 4-bit nibble neither a bytenibble).    
The branching unit is just a single bit here.  

## Features
- Very simple, concise and ___easy to read___, but ___fast___ and robust.  
- __Fully featured__ Sparse Merkle Tree (SMT) as a storage 
- This includes: ___non-inclusion proof___ , ___inclusion proof___, and _its verification_.  
- Again, NOT verbose at all.  

## Performance
All benchmarks were performed in a cumulative way, where the root resulting from an operation was reused right away next time.    
They were carried out with randomly generated bytes entries and from the root of an empty tree. (The last root was used when deleting)     
Tested on: _MacBook Pro (2.7 GHz Intel Core i5 and 16 GB 1867 MHz DDR3)_ with rustc 1.42.0 stable  

| Opertaion | DB used | #Entries | Time measured | vs. MerkleBit |
| :-------: | :-----: | -------: | :-----------: | :-----------: |
|  Insert   | HashMap |       10 |   31.56 us    |   49.64 us    |
|  Insert   | HashMap |      100 |   628.06 us   |   794.87 us   |
|  Insert   | HashMap |     1000 |   10.68 ms    |   11.84 ms    |
|  Insert   | HashMap |    10000 |   163.81 ms   |   202.02 ms   |
|  Insert   | RocksDB |       10 |   75.41 us    |       -       |
|  Insert   | RocksDB |      100 |    1.32 ms    |       -       |
|  Insert   | RocksDB |     1000 |   30.31 ms    |       -       |
|  Insert   | RocksDB |    10000 |   332.10 ms   |       -       |
|    Get    | HashMap |       10 |       -       |       -       |
|    Get    | HashMap |      100 |       -       |       -       |
|    Get    | HashMap |     1000 |       -       |       -       |
|    Get    | HashMap |    10000 |       -       |       -       |
|    Get    | RocksDB |       10 |       -       |       -       |
|    Get    | RocksDB |      100 |       -       |       -       |
|    Get    | RocksDB |     1000 |       -       |       -       |
|    Get    | RocksDB |    10000 |       -       |       -       |
|  Delete   | HashMap |       10 |       -       |       -       |
|  Delete   | HashMap |      100 |       -       |       -       |
|  Delete   | HashMap |     1000 |       -       |       -       |
|  Delete   | HashMap |    10000 |       -       |       -       |
|  Delete   | RocksDB |       10 |       -       |       -       |
|  Delete   | RocksDB |      100 |       -       |       -       |
|  Delete   | RocksDB |     1000 |       -       |       -       |
|  Delete   | RocksDB |    10000 |       -       |       -       |

_Please Be careful not to underestimate this. This already outperforms one of the famous trees from the crates for the same purpose._


## Dependancies
This library mostly relies on the _Rust standard library only_ except for hash function (`Blake2`) and database API (`Rocksdb`).

## Usage
How to generate and manipulate a new MonoTree instance

### usage::outline
```rust
    // init database, where DBTYPE := MemoryDB | RocksDB
    let mut tree = tree::MonoTree::<DBTYPE>::new(DB_PATH_OR_NAME);
    let mut root = tree.new_tree();

    // ... do something with `tree` and `root`
```

### usage::example
 ```rust
    use monotree::consts::HASH_LEN;
    use monotree::database::{MemoryDB, RocksDB};
    use monotree::tree::MonoTree;
    use monotree::utils::*;
    use monotree::*;

    fn main() {
        /// gen random 10000 key-value pair
        let pairs: Vec<(Hash, Hash)> = (0..10000)
            .map(|_| (random_bytes(HASH_LEN), random_bytes(HASH_LEN)))
            .map(|x| (slice_to_hash(&x.0).unwrap(), slice_to_hash(&x.1).unwrap()))
            .collect();

        // init tree using either In-Memory HashMap
        let mut tree = tree::MonoTree::<MemoryDB>::new(DB_NAME);
        // or RocksDB. Use only one of them at a time
        let mut tree = tree::MonoTree::<RocksdbDB>::new(DB_PATH);
        let mut root = tree.new_tree();
        
        // insert keys example with some assertions
        pairs.iter().enumerate().for_each(|(i, (key, value))| {
            // insert a key
            root = tree.insert(root.as_ref(), key, value).unwrap();

            //--- functional test: insert/get
            pairs.iter().take(i + 1).for_each(|(k, v)| {
                // check if the key-value pair was correctly inserted so far
                assert_eq!(tree.get(root.as_ref(), k).unwrap(), Some(*v));
            });
        });
        assert_ne!(root, None);

        // delete keys example with some assertions
        pairs.iter().enumerate().for_each(|(i, (key, _))| {

            //--- functional test: remove
            // assert that all values are fine after deletion
            assert_ne!(root, None);
            pairs.iter().skip(i).for_each(|(k, v)| {
                assert_eq!(tree.get(root.as_ref(), k).unwrap(), Some(*v));
            });

            // delete a key
            root = tree.remove(root.as_ref(), key).unwrap();

            // check if the key was correctly deleted
            assert_eq!(tree.get(root.as_ref(), key).unwrap(), None);
        });

        // back to inital state of tree
        assert_eq!(root, None);
    }
}
 ```
## Merkle proof example: verifying inclusion of data
### proof::outline
```rust
    // generate a proof simply,
    let proof = tree.get_merkle_proof(ROOT_REF, KEY_REF)?.unwrap();

    // verify proof: returns true or false as the result
    tree::verify_proof(ROOT_REF, VALUE, PROOF_REF)
```
### proof::example
```rust
    // suppose (key: Hash, value: Hash) alreay prepared.
    // let mut root = ...
    root = tree.insert(&root, &key, &value);
    ...

    // get a leaf related to the key interested
    let leaf = tree.get(root.as_ref(), &key).unwrap();

    // generate a proof related to the key interested
    let proof = tree.get_merkle_proof(root.as_ref(), &key)?.unwrap();

    // check if the proof is correct or not
    assert_eq!(tree::verify_proof(root.as_ref(), &leaf, &proof), true);

    // integrity: cumalative funtional test
    pairs.iter().enumerate().for_each(|(i, (key, value))| {
        // insert a key
        root = tree.insert(root.as_ref(), key, value).unwrap();

        // genenrate and verify Merkle proof with all keys so far
        pairs.iter().take(i + 1).for_each(|(k, v)| {
            let proof = tree.get_merkle_proof(root.as_ref(), k).unwrap().unwrap();
            assert_eq!(tree::verify_proof(root.as_ref(), v, &proof), true);
        });
    });
```

## Further improvements
MonoTree is a special case among the generalized binary radix trees, I'd like to call it PoT (Power Of Two) radix tree.   
If the MonoTree were generalized with `pow(2, n)` nibbles as a unit, there would have been room for further performance improvement.   
This generalization would be future-work.


## Integration tests and benchmark
performs integration tests including some unit tests.
```bash
    ## Some tests are time consuming.
    ## --release is optional, but without it, it will take a longer time to complete the tests
    $ cargo test --release
```

performs a micro-benchmark based on _Criterion [https://crates.io/crates/criterion]_
```bash
    $ cargo bench
```

and a macroscopic time-scale benchmark was also prepared in _perf.rs_ (with wider error bars).
```bash
    $ cargo run --release
```